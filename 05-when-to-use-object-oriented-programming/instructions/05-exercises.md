We've looked at various ways that objects, data, and methods can  interact with each other in an object-oriented Python program. As usual,  your first thoughts should be how you can apply these principles to  your own work. Do you have any messy scripts lying around that could be  rewritten using an object-oriented manager? Look through some of your  old code and look for methods that are not actions. If the name isn't a  verb, try rewriting it as a property.

Think about code you've  written in any language. Does it break the DRY principle? Is there any  duplicate code? Did you copy and paste code? Did you write two versions  of similar pieces of code because you didn't feel like understanding the  original code? Go back over some of your recent code now and see  whether you can refactor the duplicate code using inheritance or  composition. Try to pick a project you're still interested in  maintaining; not code so old that you never want to touch it again. That  will help to keep you interested when you do the improvements!

Now,  look back over some of the examples we looked at in this chapter. Start  with the cached web page example that uses a property to cache the  retrieved data. An obvious problem with this example is that the cache  is never refreshed. Add a timeout to the property's getter, and only  return the cached page if the page has been requested before the timeout  has expired. You can use the `time` module (`time.time() - an_old_time` returns the number of seconds that have elapsed since `an_old_time`) to determine whether the cache has expired.

Also look at the inheritance-based `ZipProcessor`. It might be reasonable to use composition instead of inheritance here. Instead of extending the class in the `ZipReplace` and `ScaleZip` classes, you could pass instances of those classes into the `ZipProcessor` constructor and call them to do the processing part. Implement this.

Which  version do you find easier to use? Which is more elegant? What is  easier to read? These are subjective questions; the answer varies for  each of us. Knowing the answer, however, is important. If you find you  prefer inheritance over composition, you need to pay attention that you  don't overuse inheritance in your daily coding. If you prefer  composition, make sure you don't miss opportunities to create an elegant  inheritance-based solution.

Finally, add some error handlers to  the various classes we created in the case study. They should ensure  single characters are entered, that you don't try to move the cursor  past the end or beginning of the file, that you don't delete a character  that doesn't exist, and that you don't save a file without a filename.  Try to think of as many edge cases as you can, and account for them  (thinking about edge cases is about 90% of a professional programmer's  job!). Consider different ways to handle them; should you raise an  exception when the user tries to move past the end of the file, or just  stay on the last character?

In your daily coding, pay attention to the **`copy`** and **`paste`**  commands. Every time you use them in your editor, consider whether it  would be a good idea to improve your program's organization so that you  only have one version of the code you are about to copy.