Look around you at some of the physical objects in your workspace and  see if you can describe them in an inheritance hierarchy. Humans have  been dividing the world into taxonomies like this for centuries, so it  shouldn't be difficult. Are there any non-obvious inheritance  relationships between classes of objects? If you were to model these  objects in a computer application, what properties and methods would  they share? Which ones would have to be polymorphically overridden? What  properties would be completely different between them?

Now write  some code. No, not for the physical hierarchy; that's boring. Physical  items have more properties than methods. Just think about a pet  programming project you've wanted to tackle in the past year, but never  gotten around to. For whatever problem you want to solve, try to think  of some basic inheritance relationships and then implement them. Make  sure that you also pay attention to the sorts of relationships that you  actually don't need to use inheritance for. Are there any places where  you might want to use multiple inheritance? Are you sure? Can you see  any place where you would want to use a mixin? Try to knock together a  quick prototype. It doesn't have to be useful or even partially working.  You've seen how you can test code using `python -i` already; just write some code and test it in the interactive interpreter. If it works, write some more. If it doesn't, fix it!

Now,  take a look at the student grader system in the case study. There is a  lot missing from it, and not just decent course content! How do students  get into the system? Is there a curriculum that defines which order  they should study lessons in? What happens if you change the `AssignmentGrader` to use inheritance, rather than composition, on the `Assignment` objects?

Finally,  try to come up with some good use cases for mixins, then experiment  with them until you realize that there is probably a better design using  composition!