The key purpose of modeling an object in object-oriented design is to determine what the public **interface**  of that object will be. The interface is the collection of attributes  and methods that other objects can access to interact with that object.  They do not need, and are often not allowed, to access the internal  workings of the object.

A common real-world example is the  television. Our interface to the television is the remote control. Each  button on the remote control represents a method that can be called on  the television object. When we, as the calling object, access these  methods, we do not know or care if the television is getting its signal  from a cable connection, a satellite dish, or an internet-enabled  device. We don't care what electronic signals are being sent to adjust  the volume, or whether the sound is destined for speakers or headphones.  If we open the television to access the internal workings, for example,  to split the output signal to both external speakers and a set of  headphones, we will void the warranty.

This process of hiding the implementation of an object is suitably called **information hiding**. It is also sometimes referred to as **encapsulation**, but encapsulation  is actually a more all-encompassing term. Encapsulated data is not  necessarily hidden. Encapsulation is, literally, creating a capsule  (think of creating a time capsule). If you put a bunch of information  into a time capsule, and lock and bury it, it is both encapsulated and  the information is hidden. On the other hand, if the time capsule, has  not been buried and is unlocked or made of clear plastic, the items  inside it are still encapsulated, but there is no information hiding.

The  distinction between encapsulation and information hiding is largely  irrelevant, especially at the design level. Many practical references  use these terms interchangeably. As Python programmers, we don't  actually have or need true information hiding (we'll discuss the reasons  for this in **Objects in Python**), so the more encompassing definition for encapsulation is suitable.

The  public interface, however, is very important. It needs to be carefully  designed as it is difficult to change it in the future. Changing the  interface will break any client objects that are accessing it. We can  change the internals all we like, for example, to make it more  efficient, or to access data over the network as well as locally, and  the client objects will still be able to talk to it, unmodified, using  the public interface. On the other hand, if we alter the interface by  changing publicly accessed attribute names or the order or types of  arguments that a method can accept, all client classes will also have to  be modified. When designing public interfaces, keep it simple. Always  design the interface of an object based on how easy it is to use, not how hard it is to code (this advice applies to user interfaces as well).

Remember,  program objects may represent real objects, but that does not make them  real objects. They are models. One of the greatest gifts of modeling is  the ability to ignore irrelevant details. The model car I built as a  child looked like a real 1956 Thunderbird on the outside, but it  obviously doesn't run. When I was too young to drive, these details were  overly complex and irrelevant. The model is an **abstraction** of a real concept.

**Abstraction** is another object-oriented term related  to encapsulation and information hiding.  Abstraction means dealing  with the level of detail that is most appropriate to a given task. It is  the process of extracting a public interface from the inner details. A  car's driver needs to interact with the steering, accelerator, and  brakes. The workings of the motor, drive train, and brake subsystem  don't matter to the driver. A mechanic, on the other hand, works at a  different level of abstraction, tuning the engine and bleeding the  brakes. Here's an example of two abstraction levels for a car:

![img](https://static.packt-cdn.com/products/9781789615852/graphics/8e30c5fe-0e03-4f41-9df5-d1ce9b79e8ab.png)

Now, we have several new terms that refer to similar concepts. Let's  summarize all this jargon in a couple of sentences: abstraction is the  process of encapsulating information with separate public and private  interfaces. The private interfaces can be subject to information hiding.

The important lesson to take from all these definitions is to make our models understandable to other objects that have to interact with them. This means paying careful attention  to small details. Ensure methods and properties have sensible names.  When analyzing a system, objects typically represent nouns in the  original problem, while methods are normally verbs. Attributes may show  up as adjectives or more nouns. Name your classes, attributes, and  methods accordingly.

When designing the interface, imagine you are  the object and that you have a very strong preference for privacy.  Don't let other objects have access to data about you unless you feel it  is in your best interest for them to have it. Don't give them an  interface to force you to perform a specific task unless you are certain  you want them to be able to do that to you.