We discussed three  types of relationships between objects: association, composition, and  aggregation. However, we have not fully specified our chess set, and  these tools don't seem to give us all the power we need. We discussed  the possibility that a player might be a human or it might be a piece of  software featuring artificial intelligence. It doesn't seem right to  say that a player is **associated** with a human, or that the artificial intelligence implementation is **part of** the player object. What we really need is the ability to say that **Deep Blue is a player**, or that **Gary Kasparov is a player**.

The **is a** relationship is formed by **inheritance**.  Inheritance is the most famous, well-known, and over-used relationship  in object-oriented programming. Inheritance is sort of like a family  tree. My grandfather's last name was Phillips and my father inherited  that name. I inherited it from him. In object-oriented programming,  instead of inheriting features and behaviors from a person, one class  can inherit attributes and methods from another class.

For  example, there are 32 chess pieces in our chess set, but there are only  six different types of pieces (pawns, rooks, bishops, knights, king, and  queen), each of which behaves differently when it is moved. All of  these classes of piece have properties, such as color and the chess set  they are part of, but they also have unique shapes when drawn on the  chess board, and make different moves. Let's see how the six types of  pieces can inherit from a **Piece** class:

![img](https://static.packt-cdn.com/products/9781789615852/graphics/04cf32aa-ea19-4f70-a525-a2b1a122a9ed.png)

The hollow arrows indicate that the individual classes of pieces inherit from the **Piece** class. All the child classes automatically have a **chess_set** and **color**  attribute inherited from the base class. Each piece provides a  different shape property (to be drawn on the screen when rendering the  board), and a different **move** method to move the piece to a new position on the board at each turn.

We actually know that all subclasses of the **Piece** class need to have a **move**  method; otherwise, when the board tries to move the piece, it will get  confused. It is possible that we would want to create a new version of  the game of chess that has one additional piece (the wizard). Our  current design will allow us to design this piece without giving it a **move** method. The board would then choke when it asked the piece to move itself.

We can fix this by creating a dummy move method on the **Piece** class. The subclasses can then **override**  this method with a more specific implementation. The default  implementation might, for example, pop up an error message that says **That piece cannot be moved**.

Overriding  methods in subclasses allows very powerful object-oriented systems to  be developed. For example, if we wanted to implement a **Player** class with artificial intelligence, we might provide a `calculate_move` method that takes a **Board**  object and decides which piece to move where. A very basic class might  randomly choose a piece and direction and move it accordingly. We could  then override this method in a subclass with the Deep Blue  implementation. The first class would be suitable for play against a raw  beginner; the latter would challenge a grand master. The important  thing is that other methods in the class, such as the ones that inform  the board as to which move was chosen, need not be changed; this  implementation can be shared between the two classes.

In the case of chess pieces, it doesn't really  make sense to provide a default implementation of the move method. All  we need to do is specify that the move method is required in any  subclasses. This can be done by making **Piece** an **abstract class** with the move method declared **abstract**. Abstract methods basically say this:

> **We demand this method exist in any non-abstract subclass, but we are declining to specify an implementation in this class.**

Indeed,  it is possible to make a class that does not implement any methods at  all. Such a class would simply tell us what the class should do, but  provides absolutely no advice on how to do it. In object-oriented parlance, such classes are called **interfaces**.

# Inheritance Provides Abstraction

Let's explore the longest word in object-oriented argot. **Polymorphism** is the ability  to treat a class differently, depending on which subclass is  implemented. We've already seen it in action with the pieces system  we've described. If we took the design a bit further, we'd probably see  that the **Board** object can accept a move from the player and call the **move** function on the piece. The board need not ever know what type of piece it is dealing with. All it has to do is call the **move** method, and the proper subclass will take care of moving it as a **Knight** or a **Pawn**.

Polymorphism  is pretty cool, but it is a word that is rarely used in Python  programming. Python goes an extra step past allowing a subclass of an  object to be treated like a parent class. A board implemented in Python  could take any object that has a **move** method, whether it is a bishop piece, a car, or a duck. When **move** is called, the **Bishop** will move diagonally on the board, the car will drive someplace, and the duck will swim or fly, depending on its mood.

This sort of polymorphism in Python is typically referred to as **duck typing**: **if it walks like a duck or swims like a duck, it's a duck**. We don't care if it really *is a* duck (*is a* being  a cornerstone of inheritance), only that it swims or walks. Geese and  swans might easily be able to provide the duck-like behavior we are  looking for. This allows future designers to create new types of birds  without actually specifying an inheritance hierarchy for aquatic birds.  It also allows them to create completely different drop-in behaviors  that the original designers never planned for. For example, future  designers might be able to make a walking, swimming penguin that works  with the same interface without ever suggesting that penguins are ducks.

# Multiple Inheritance

When we think of inheritance  in our own family tree, we can see that we inherit features from more  than just one parent. When strangers tell a proud mother that her son  has **his father's eyes**, she will typically respond along the lines of, **yes, but he got my nose**.

Object-oriented design can also feature such **multiple inheritance**,  which allows a subclass to inherit functionality from multiple parent  classes. In practice, multiple inheritance can be a tricky business, and  some programming languages (most famously, Java) strictly prohibit it.  However, multiple inheritance can have its uses. Most often, it can be  used to create objects that have two distinct sets of behaviors. For  example, an object designed to connect to a scanner and send a fax of  the scanned document might be created by inheriting from two separate `scanner` and `faxer` objects.

As  long as two classes have distinct interfaces, it is not normally  harmful for a subclass to inherit from both of them. However, it gets  messy if we inherit from two classes that provide overlapping  interfaces. For example, if we have a motorcycle class that has a `move` method, and a boat class also featuring a `move`  method, and we want to merge them into the ultimate amphibious vehicle,  how does the resulting class know what to do when we call `move`?  At the design level, this needs to be explained, and, at the  implementation level, each programming language has different ways of  deciding which parent class's method is called, or in what order.

Often, the best way to deal with it is to avoid it. If you have a design showing up like this, you're **probably**  doing it wrong. Take a step back, analyze the system again, and see if  you can remove the multiple inheritance relationship in favor of some  other association or composite design.

Inheritance is a very  powerful tool for extending behavior. It is also one of the most  marketable advancements of object-oriented design over earlier  paradigms. Therefore, it is often the first tool that object-oriented  programmers reach for. However, it is important to recognize that owning  a hammer does not turn screws into nails. Inheritance is the perfect  solution for obvious *is a* relationships, but it can be abused. Programmers often use inheritance to share code between two kinds of objects that are only distantly related, with no *is a*  relationship in sight. While this is not necessarily a bad design, it  is a terrific opportunity to ask just why they decided to design it that  way, and whether a different relationship or design pattern would have been more suitable.