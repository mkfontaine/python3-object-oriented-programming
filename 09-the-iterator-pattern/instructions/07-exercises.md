If you don't use comprehensions in your daily coding very often, the  first thing you should do is search through some existing code and find  some `for` loops. See whether any of them can  be trivially converted to a generator expression or a list, set, or  dictionary comprehension.

Test the claim that list comprehensions are faster than `for` loops. This can be done with the built-in `timeit` module. Use the help documentation for the `timeit.timeit`  function to find out how to use it. Basically, write two functions that  do the same thing, one using a list comprehension, and one using a `for` loop to iterate over several thousand items. Pass each function into `timeit.timeit`,  and compare the results. If you're feeling adventurous, compare  generators and generator expressions as well. Testing code using `timeit`  can become addictive, so bear in mind that code does not need to be  hyperfast unless it's being executed an immense number of times, such as  on a huge input list or file.

Play around with generator  functions. Start with basic iterators that require multiple values  (mathematical sequences are canonical examples; the Fibonacci sequence  is overused if you can't think of anything better). Try some more  advanced generators that do things such as take multiple input lists and  somehow yield values that merge them. Generators can also be used on  files; can you write a simple generator that shows lines that are  identical in two files?

Coroutines abuse the iterator protocol but  don't actually fulfill the iterator pattern. Can you build a  non-coroutine version of the code that gets a serial number from a log  file? Take an object-oriented approach so that you can store an  additional state on a class. You'll learn a lot about coroutines if you  can create an object that is a drop-in replacement for the existing  coroutine.

The case study for this chapter has a lot of odd tuples  of tuples being passed around that are hard to keep track of. See  whether you can replace those return values with more object-oriented  solutions. Also, experiment with moving some of the functions that share  data (for example, `model_colors` and `target_colors`) into a class. That should reduce the number of arguments that have to be passed into most of the generators since they can look them up on `self`.