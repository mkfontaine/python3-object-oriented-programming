When engineers and architects decide  to build a bridge, or a tower, or a building, they follow certain  principles to ensure structural integrity. There are various possible  designs for bridges (suspension and cantilever, for example), but if the  engineer doesn't use one of the standard designs, and doesn't have a  brilliant new design, it is likely the bridge he/she designs will  collapse.

Design patterns are an attempt to bring this same formal  definition for correctly designed structures to software engineering.  There are many different design patterns to solve different general  problems. Design patterns typically solve a specific common problem  faced by developers in some specific situation. The design pattern is  then a suggestion as to the ideal solution for that problem, in terms of  object-oriented design.

Knowing a design pattern and choosing to use it in our software does not, however, guarantee that we are creating a *correct* solution.  In 1907, the Qu√©bec Bridge (to this day, the longest cantilever bridge  in the world) collapsed before construction was completed, because the  engineers who designed it grossly underestimated the weight of the steel  used to construct it. Similarly, in software development, we may  incorrectly choose or apply a design pattern, and create software that *collapses* under normal operating situations or when stressed beyond its original design limits.

Any  one design pattern proposes a set of objects interacting in a specific  way to solve a general problem. The job of the programmer is to  recognize when they are facing a specific version of such a problem,  then to choose and adapt the general design in their precise needs.

In  this lesson, we'll be covering the iterator design pattern. This  pattern is so powerful and pervasive that the Python developers have  provided multiple syntaxes to access the object-oriented principles  underlying the pattern. We will be covering other design patterns  in the next two chapters. Some of them have language support and some  don't, but none of them is so intrinsically a part of the Python coder's  daily life as the iterator pattern.python3-object-oriented-programming