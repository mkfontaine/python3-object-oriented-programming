This lesson ends our exploration of object-oriented programming with  a topic that isn't very object-oriented. Concurrency is a difficult  problem, and we've only scratched the surface. While the underlying OS  abstractions of processes and threads do not provide an API that is  remotely object-oriented, Python offers some really good object-oriented  abstractions around them. The threading and multiprocessing packages  both provide an object-oriented interface to the underlying mechanics.  Futures are able to encapsulate a lot of the messy details into a single  object. AsyncIO uses coroutine objects to make our code read as though  it runs synchronously, while hiding ugly and complicated implementation  details behind a very simple loop abstraction.