In this lesson, we went into detail on several more design patterns,  covering their canonical descriptions as well as alternatives for  implementing them in Python, which is often more flexible and versatile  than traditional object-oriented languages. The adapter pattern is  useful for matching interfaces, while the facade pattern is suited to  simplifying them. Flyweight is a complicated pattern and only useful if  memory optimization is required. In Python, the command pattern is often  more aptly implemented using first class functions as callbacks.  Abstract factories allow runtime separation of implementations depending  on configuration or system information. The composite pattern is used  universally for tree-like structures.

This is the last of the  truly object-oriented lesson in this course, but I've thrown in a couple  of freebies on topics very dear to my heart. In the next chapter, we'll  discuss how important it is to test Python programs, and how to do it,  focusing on object-oriented principles.