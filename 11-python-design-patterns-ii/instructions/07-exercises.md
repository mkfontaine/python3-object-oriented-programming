Before diving into activities for each design pattern, take a moment to implement the `copy` method for the `File` and `Folder` objects in the previous section. The `File`  method should be quite trivial; just create a new node with the same  name and contents, and add it to the new parent folder. The `copy` method on `Folder`  is quite a bit more complicated, as you first have to duplicate the  folder, and then recursively copy each of its children to the new  location. You can call the `copy()` method on  the children indiscriminately, regardless of whether each is a file or a  folder object. This will drive home just how powerful the composite  pattern can be.

Now, as in the previous chapter, look at the  patterns we've discussed and consider ideal places where you might  implement them. You may want to apply the adapter pattern to existing  code, as it is usually applicable when interfacing with existing  libraries, rather than new code. How can you use an adapter to force two  interfaces to interact with each other correctly?

Can you think  of a system complex enough to justify using the facade pattern? Consider  how facades are used in real-life situations, such as the driver-facing  interface of a car, or the control panel in a factory. It is similar in  software, except the users of the facade interface are other  programmers, rather than people trained to use them. Are there complex  systems in your latest project that could benefit from the facade  pattern?

It's possible you don't have any huge, memory-consuming  code that would benefit from the flyweight pattern, but can you think of  situations where it might be useful? Anywhere that large amounts of  overlapping data need to be processed, a flyweight is waiting to be  used. Would it be useful in the banking industry? In web applications?  At what point does adopting the flyweight pattern make sense? When is it  overkill?

What about the command pattern? Can you think of any  common (or better yet, uncommon) examples of places where the decoupling  of action from invocation would be useful? Look at the programs you use  on a daily basis and imagine how they are implemented internally. It's  likely that many of them use the command pattern for one purpose or  another.

The abstract factory pattern, or the somewhat more  Pythonic derivatives we discussed, can be very useful for creating  one-touch-configurable systems. Can you think of places where such  systems are useful?

Finally, consider the composite pattern. There  are tree-like structures all around us in programming; some of them,  like our file hierarchy example, are blatant; others are fairly subtle.  What situations might arise where the composite pattern would be useful?  Can you think of places where you can use it in your own code? What if  you adapted the pattern slightly; for example, to contain different  types of leaf or composite nodes for different types of objects?