We've covered a wide variety of topics in this chapter, from strings  to regular expressions, to object serialization, and back again. Now  it's time to consider how these ideas can be applied to your own code.

Python  strings are very flexible, and Python is an extremely powerful tool for  string-based manipulations. If you don't do a lot of string processing  in your daily work, try designing a tool that is exclusively intended  for manipulating strings. Try to come up with something innovative, but  if you're stuck, consider writing a web log analyzer (how many requests  per hour? How many people visit more than five pages?) or a template  tool that replaces certain variable names with the contents of other  files.

Spend a lot of time toying with the string formatting  operators until you've got the syntax memorized. Write a bunch of  template strings and objects to pass into the format function, and see  what kind of output you get. Try the exotic formatting operators, such  as percentage or hexadecimal notation. Try out the fill and alignment  operators, and see how they behave differently for integers, strings,  and floats. Consider writing a class of your own that has a `__format__` method; we didn't discuss this in detail, but explore just how much you can customize formatting.

Make sure you understand the difference between `bytes` and `str` objects. The distinction is very complicated in older versions of Python (there was no `bytes`, and `str` acted like both `bytes` and `str` unless we needed non-ASCII characters, in which case there was a separate `unicode` object, which was similar to Python 3's `str` class. It's even more confusing than it sounds!). It's clearer nowadays; `bytes` is for binary data, and `str`  is for character data. The only tricky part is knowing how and when to  convert between the two. For practice, try writing text data to a file  opened for writing `bytes` (you'll have to encode the text yourself), and then reading from the same file.

Do some experimenting with `bytearray`. See how it can act both like a `bytes`  object and a list or container object at the same time. Try writing to a  buffer that holds data in the bytes array until it is a certain length  before returning it. You can simulate the code that puts data into the  buffer by using `time.sleep` calls to ensure data doesn't arrive too quickly.

Study  regular expressions online. Study them some more. Especially learn  about named groups, greedy versus lazy matching, and regex flags, three  features that we didn't cover in this chapter. Make conscious decisions  about when not to use them. Many people have very strong opinions about  regular expressions and either overuse them or refuse to use them at  all. Try to convince yourself to use them only when appropriate, and  figure out when that is.

If you've ever written an adapter to load  small amounts of data from a file or database and convert it to an  object, consider using a pickle instead. Pickles are not efficient for  storing massive amounts of data, but they can be useful for loading  configuration or other simple objects. Try coding it multiple ways:  using a pickle, a text file, or a small database. Which do you find  easiest to work with?

Try experimenting with pickling data, then  modifying the class that holds the data, and loading the pickle into the  new class. What works? What doesn't? Is there a way to make drastic  changes to a class, such as renaming an attribute or splitting it into  two new attributes and still get the data out of an older pickle? (Hint:  try placing a private pickle version number on each object and update  it each time you change the class; you can then put a migration path in `__setstate__`.)

If  you do any web development at all, do some experimenting with the JSON  serializer. Personally, I prefer to serialize only standard JSON  serializable objects, rather than writing custom encoders or `object_hooks`, but the desired effect really depends on the interaction between the frontend (JavaScript, typically) and backend code.

Create  some new directives in the templating engine that take more than one or  an arbitrary number of arguments. You might need to modify the regular  expression or add new ones. Have a look at the Django project's online  documentation, and see whether there are any other template tags you'd  like to work with. Try mimicking their filter syntax instead of using  the `variable` tag.

Revisit this  lesson when you've studied iteration and coroutines and see whether you  can come up with a more compact way of representing the state between  related directives, such as the loop.